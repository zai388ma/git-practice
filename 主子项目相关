###视频学习笔记
- 子项目就是一个组件库。加载子页面时页面并没有跳转。
- 子项目和主项目要同步缓存 ，接口出错的统一处理。
- 添加子项目的时候，在菜单管理添加一个菜单，类型为应用。
- 举例，数据运营点击，出现的左侧菜单栏是从主项目的缓存里拿来的。
- 主项目如何加载子项目，如何处理子项目的路由：子项目做一些改造，把子项目的路由抛出来，主项目需要有一个注册操作。
- 主项目加载子项目用的是全局变量webpackJsonP,但要改一个名字否则会冲突。加下划线_服务名称。
- 主项目中配了子项目代理，现有的子项目是部署在nginx下的目录。
- 菜单管理中的应用类型的菜单的路由地址就是在vue.config.js文件中配置的代理的路径
- 点击相应菜单时，会去找菜单列表中相应的菜单，路由会变化为相应的地址。根据#后面的第一个名称再去菜单管理里面找，跳到相应的
路由地址，加载子项目里的配置文件（config.json文件），解析这个文件，并把该文件中包含的文件通过script标签加载进来
。（service-interceptor中的拦截器会监听路由地址的改变并执行这些操作）子项目中在micro.......compiler.js文件中有一个webpack的插件，
在子项目的vue.config.js中引入这个插件，并配置。
- 主项目抛出了全局的方法给子项目去注册子项目的路由。
- 把主项目的axios方法抛出可以不用主项目自己发请求，能够统一处理报错？
- 主项目加载时把vuex,axios,elementUI等设置为全局的，所以子项目用的时候不需要去import？？这样
子项目打包就不需要这些东西了，减小打包体积，不会导致这些重复加载。
- 子项目通过window.app.require这个主项目抛出的方法可以动态加载echarts等插件。
- 子项目中调用的this和this.$router对象指向的都是主项目里的根节点对象。但可能会导致冲突，子项目能有自己的缓存，
是挂载在全局对象上，可以通过this.$store_服务名称/Vue.prototype[STORE_KEY]来获取子项目的缓存。
- 子项目中要发ajax请求时，通过主项目抛出的Vue.prototype.$http（axios实例），这样拦截器什么的都能代理到。
- v-perm是主项目全局注册的一个指令
- webpackjosnP这个全局对象的作用就是去加载异步组件，比如user.js，打包成user.chunk.js文件，往这个组件页面跳的时候，实际上是
vueRouter里面去执行webpackJsonP的方法去加载user.chunk.js文件.子项目也会有这个对象，所以要改变命名，才不会与主项目冲突。
- 子项目也是需要打包的
- 现在是用nginx，为了可持续集成。
- 数据资源 是菜单类型，下面的两个是应用类型。应用下面只能配菜单和按钮。
比如点击数据运营的时候，会自动提取数据管理下面类型为菜单的菜单名称，生成左侧的菜单栏。通过这种配置，
主项目才能实现对菜单的权限控制。
- replace(正则表达式，新字符串)
- 页面分辨率适配？
- 
